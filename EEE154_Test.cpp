/**
* @author Adam Kavanagh B00631162 <kavanagh-a1@email.ulster.ac.uk>
*
* @license (https://github.com/TurnersAngels/EEE507_Coursework/blob/master/LICENSE)
* @copyright Adam Kavanagh 2017
*
* This is the test code written to evaluate the effectiveness of the calculations
* being performed within class EEE154. It checks every variation of each equation 
* with variables which result in correct and incorrect answers to double check 
* that it is operating as expected.
*
* As can be seen from the tests below i tried a variety of test cases when i was
* evaluating whether the functions should return an incorrect answer to the ideal
* answer specified. This included the wrong sign, the incorrect numerical answer,
* wrong power of ten etc.
*
* @todo need to figure out a way to test the switch statements which make up the
* logical decision making process of the project.
*
* @todo couldn't get 'AreEqual' to work so instead I had to use IsTrue. Need to 
* figure out how to replace IsTrue with 'AreEqual'.
*/

//including required header files, some generated on creation of test file
#include "stdafx.h"
#include "CppUnitTest.h"
#include "../EEE507_CourseWork/EEE154.h"

using namespace Microsoft::VisualStudio::CppUnitTestFramework;

namespace Tests
{
	TEST_CLASS(UnitTest1) //Creating Class UnitTest1
	{
	public: EEE154 object1; //Creating public object

			/**
			* TEST_METHOD(ohms_eqn_1_T) uses IsTrue function to check whether 
			* the contents within the brackets are true and if so the test is
			* passed. Within the brackets the equivalent function is being called 
			* to evaluate whether the entered constant, in this case 2, is equal to
			* the value generated by the specified function 'Ohms_calculation' using
			* the values specified 10 and 5. This should in theory return as being equal
			* and therefore be true, resulting in the test being passed.
			*/

			TEST_METHOD(ohms_eqn_1_T) //defining test and giving it a name
			{
				Assert::IsTrue(equivalent(2, object1.Ohms_calculation_1(10,5)));
			}

			/**
			* TEST_METHOD(ohms_eqn_1_F) uses IsFalse function to check whether
			* the contents within the brackets are false and if so the test is
			* passed. Within the brackets the equivalent function is being called
			* to evaluate whether the entered constant, in this case 3.33, is equal to
			* the value generated by the specified function 'Ohms_calculation' using
			* the values specified 10 and 5. This should in theory return as being unequal
			* and therefore be false, resulting in the test being passed.
			*/

			TEST_METHOD(ohms_eqn_1_F)
			{
				Assert::IsFalse(equivalent(3.33, object1.Ohms_calculation_1(10, 5)));
			}

			TEST_METHOD(ohms_eqn_2_T)
			{
				Assert::IsTrue(equivalent(4, object1.Ohms_calculation_2(20, 5)));
			}

			TEST_METHOD(ohms_eqn_2_F)
			{
				Assert::IsFalse(equivalent(4, object1.Ohms_calculation_2(-20, 5)));
			}

			TEST_METHOD(ohms_eqn_3_T)
			{
				Assert::IsTrue(equivalent(50, object1.Ohms_calculation_3(-10, -5)));
			}

			TEST_METHOD(ohms_eqn_3_F)
			{
				Assert::IsFalse(equivalent(4, object1.Ohms_calculation_3(-20, 0.5)));
			}

			TEST_METHOD(power_eqn_1_T)
			{
				Assert::IsTrue(equivalent(102, object1.Power_calculation_1(17, 6)));
			}

			TEST_METHOD(power_eqn_1_F)
			{
				Assert::IsFalse(equivalent(1, object1.Power_calculation_1(17.5464, 6)));
			}

			TEST_METHOD(power_eqn_2_T)
			{
				Assert::IsTrue(equivalent(0.4, object1.Power_calculation_2(2, 5.0)));
			}

			TEST_METHOD(power_eqn_2_F)
			{
				Assert::IsFalse(equivalent(-0.4, object1.Power_calculation_2(2, 5.0)));
			}

			TEST_METHOD(power_eqn_3_T)
			{
				Assert::IsTrue(equivalent(4, object1.Power_calculation_3(10, 2.5)));
			}

			TEST_METHOD(power_eqn_3_F)
			{
				Assert::IsFalse(equivalent(-4, object1.Power_calculation_3(-10, -2.5)));
			}

			TEST_METHOD(charge_eqn_1_T)
			{
				Assert::IsTrue(equivalent(0.0625, object1.Charge_calculation_1(0.25, 0.25)));
			}

			TEST_METHOD(charge_eqn_1_F)
			{
				Assert::IsFalse(equivalent(0.625, object1.Charge_calculation_1(0.25, 0.25)));
			}

			TEST_METHOD(charge_eqn_2_T)
			{
				Assert::IsTrue(equivalent(1, object1.Charge_calculation_2(10, 10)));
			}

			TEST_METHOD(charge_eqn_2_F)
			{
				Assert::IsFalse(equivalent(5, object1.Charge_calculation_2(10, 010)));
			}

			TEST_METHOD(charge_eqn_3_T)
			{
				Assert::IsTrue(equivalent(-0.9, object1.Charge_calculation_3(-4.5, 5)));
			}

			TEST_METHOD(charge_eqn_3_F)
			{
				Assert::IsFalse(equivalent(-9, object1.Charge_calculation_3(-4.5, 5)));
			}

			/**
			* Creation of the equivalent function to use in the above tests to evaluate
			* whether the defined constant is equal to the calculated value produced
			* by the functions.
			*
			* @deprecated I do not intend to use this function in the future as I would
			* prefer to figure out how to use the AreEqual and NotEqual functions already
			* built in to visual studios. This is only a temporary solution! However there#
			* are some advantages of this method, one being that using the normal == won't
			* necessarily work with most cases as working with doubles there is an 
			* opportunity for rounding errors to occur. 
			*/

			bool UnitTest1::equivalent(double a, double b, const double epsilon = 1e-5) //creating function
			{
				double c = a - b;
				return c < epsilon && -c < epsilon;
			}
	};

}